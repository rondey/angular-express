<!-- Developed By Davide Antonino Vincenzo Micale -->
<!-- Il contentitore è il flex container, utile per poter organizzare le dimensioni degli elementi in modo responsive.
     Con fxLayout definisco sia l'ordine con cui i contenitori dovranno essere visualizzati. Nel caso specifico è stato
     impostato che i contenitori dovranno essere mostrati uno dopo l'altro in un'unica riga.
     Con fxLayout.lt-md impongo che la regola deve essere usata nel caso di schermo più piccolo del medio. Nel caso
     specifico è stato impostato che i contenitori dovranno essere mostrati in un'unica colonna uno
     dopo l'altro.
     Con fxLayoutAlign definisco l'allineamento dei contenitori per ciascun asse. Nel caso specifico è stato impostato
     con space-evenly che distribuisce lo spazio libero in maniera uguale fra i contenitori, mentre nell'asse verticale 
     è stato impostato con stretch che i contentitori prendessero tutta l'altezza disponibile.
     Con fxLayoutAlign.lt-md definisco l'allineamento dei contenitori per ciascun asse nel caso di schermo più piccolo
     del medio. Nel caso specifico è stato impostato con start che per l'asse orizzontale si parte dalla sinistra andando 
     verso destra e tutto l'eventuale spazio rimanente và a destra, mentre nell'asse verticale è stato impostato con 
     stretch che i contentitori prendessero tutta l'altezza disponibile -->
<div class="main-content" fxLayout="row" fxLayout.lt-md="column" fxLayoutAlign="space-evenly stretch" fxLayoutAlign.lt-md="start stretch">
  <!-- Con fxFlex imposto come si dovrà ridimensionare il contenitore. Nel caso specifico, con nogrow il contentitore prenderà lo
             spazio in grandezza che gli serve. Se c'è altro spazio vuoto disponibile, lui non ne potrà usufruire -->
  <div fxFlex="nogrow">
    <!-- Creo una card per contenere i filtri-->
    <mat-card>
      <!-- Nell'header inserisco il titolo della card-->
      <mat-card-header>
        <h4>Filtri</h4>
      </mat-card-header>
      <!-- Nel contenuto inserisco i filtri-->
      <mat-card-content>
        <!-- I campi sono inseriti all'interno del form per sfruttare principalmente l'observable offerto dal formGroup che
                       a ogni modifica effettuata nei campi emette un evento. Con [formGroup] associo il formGroup di nome filtersForm definito 
                       nel component e lo associo al form -->
        <form name="filtersForm" [formGroup]="filtersForm">
          <div>
            <!-- Il primo campo, con stile angular material, è l'eventSchedule che contiene il filtraggio del nome dell'evento -->
            <mat-form-field>
              <!-- matInput permette di impostare gli stili angular all'elemento. 
                                  Con aria-label indico una descrizione che possa essere mostrata da coloro che usano gli screen reader principalmente.
                                  Con formControlName indico al formGroup con quale nome il campo deve associato. In questo caso, all'interno del
                                  componente, questo campo avrà come nome eventSchedule
                                  Con placeholder indico il testo che deve essere mostrato quando non è stato scritto nulla nel campo di input. Grazie
                                  a Material questo testo non scompare quando si scrive nel campo, bensì si trasforma in etichetta del campo -->
              <input type="text" name="name" matInput aria-label="Nome della stanza" placeholder="Nome dell'evento" formControlName="name">
            </mat-form-field>
          </div>
          <div>
            <mat-form-field>
              <!-- matInput permette di impostare gli stili angular all'elemento. 
                                  Con aria-label indico una descrizione che possa essere mostrata da coloro che usano gli screen reader principalmente.
                                  Con formControlName indico al formGroup con quale nome il campo deve associato. In questo caso, all'interno del
                                  componente, questo campo avrà come nome eventSchedule
                                  Con placeholder indico il testo che deve essere mostrato quando non è stato scritto nulla nel campo di input. Grazie
                                  a Material questo testo non scompare quando si scrive nel campo, bensì si trasforma in etichetta del campo -->
              <input type="number" min="0" name="capacityMin" matInput aria-label="Capacità minima" placeholder="Capacità minima" formControlName="capacityMin">
            </mat-form-field>
          </div>
          <div>
            <mat-form-field>
              <!-- matInput permette di impostare gli stili angular all'elemento. 
                                  Con aria-label indico una descrizione che possa essere mostrata da coloro che usano gli screen reader principalmente.
                                  Con formControlName indico al formGroup con quale nome il campo deve associato. In questo caso, all'interno del
                                  componente, questo campo avrà come nome eventSchedule
                                  Con placeholder indico il testo che deve essere mostrato quando non è stato scritto nulla nel campo di input. Grazie
                                  a Material questo testo non scompare quando si scrive nel campo, bensì si trasforma in etichetta del campo -->
              <input type="number" min="0" name="capacityMax" matInput aria-label="Capacità massima" placeholder="Capacità massima" formControlName="capacityMax">
            </mat-form-field>
          </div>
          <div>
            <!-- mat-Checkbox per mostrare il cheeckbox in stile material-->
            <mat-checkbox name="wifi" aria-label="Internet WiFi" formControlName="wifi">Internet WiFi</mat-checkbox>
          </div>
          <div>
            <mat-checkbox name="socket" aria-label="Prese di corrente" formControlName="socket">Prese di corrente</mat-checkbox>
          </div>
          <div>
            <mat-checkbox name="ethernet" aria-label="Prese ethernet" formControlName="ethernet">Prese ethernet</mat-checkbox>
          </div>
          <div>
            <mat-checkbox name="computer" aria-label="Computer" formControlName="computer">Computer</mat-checkbox>
          </div>
          <div>
            <mat-checkbox name="interactiveWhiteboard" aria-label="Lavagna interattiva" formControlName="interactiveWhiteboard">Lavagna interattiva</mat-checkbox>
          </div>
        </form>
        <div>
          <!-- Il bottone si occupa di resettare i campi del form. 
                           Con mat-raised-button indico lo stile del bottone.
                           Con color indico lo schema di colori che deve possedere il bottone, in questo caso il secondario
                           Con (click) associo l'evento del click dell'utente del bottone alla funzione reset() presente nello CalendarComponent
                           Il tag mat-icon permette di mostrare una icona a schermo. Viene passato il nome dell'icona da visualizzare che in 
                           questo caso è l'icona clear -->
          <button mat-raised-button color="secondary" (click)="reset()">
            <mat-icon>clear</mat-icon> Reset</button>
        </div>
      </mat-card-content>
    </mat-card>
  </div>
  <!-- Con fxFlex impostato a 0 1 50% indico rispettivamente che il contenitore non usufruirà di eventuale spazio disponibile (non si
             ingrandirà in presenza di spazio libero), di rimpicciolirsi se è troppo largo da non riuscire ad entrarci e del 50% come 
             dimensione iniziale (prima della fase di ingrandimento, che in questo caso non è sfruttata da nessuno) -->
  <div fxFlex="0 1 50%;">
    <!-- Mostro il componente che si occupa di mostrare a schermo uno spinner finchè l'array rooms non viene caricato-->
    <app-loading [elements]="rooms"></app-loading>
    <!-- Devo mostrare una card per ogni aula. Si usa *ngFor a cui viene passato un array e per ognuno
                 di esso crea l'elemento. Utilizzando però gli operatori pipe è possibile applicare delle trasformazioni all'array che verrò
                 passato all' *ngFor. È possibile applicare più di una pipe, concatenandoli attraverso l'uso del carattere | . Una pipe può
                 prendere come input non necessariamente array ma più in generale oggetti o variabili semplici. Bisogna indicare 
                 il nome della pipe e opzionalmente possono avere parametri, separati dal carattere : . Oltre alle pipe fornite da Angular,
                 è possibile creare delle pipe custom. In questo caso si usano delle pipe custom. Queste pipe, nello specifico, hanno lo 
                 scopo di filtrare l'array, facendo passare solo gli elementi dell'array che rispettano certi criteri. Il searchfilter 
                 lascia passare solo gli oggetti che presentano in un campo specifico una determinata sottostringa. Come parametri in 
                 ingresso prende il nome della proprietà da filtrare e la stringa da cercare. Nel nostro caso, all'interno dell'array
                 di eventi, si vuole cercare nel campo name la sottostringa eventSchedule che si trova eventualmente 
                 all'interno dell'oggetto filters. Grazie al '?', se il filtro dovesse essere nullo, non si verificherebbe un errore
                 JavaScript. 
                 Con la pipe numberfilter, anch'essa custom, viene fatto un confronto fra due numeri. In base all'operatore scelto (uguaglianza,
                 minoranza, maggioranza e combinazioni) si stabilirà se l'elemento farà parte o meno dell'array finale. Il numberfilter prende
                 in ingresso il nome della proprietà da filtrare e un oggetto che contiene il numero da confrontare e l'operatore indicato
                 tramite stringhe. Nel nostro caso viene applicato il filtro alla capacità dell'aula confrontato col corrispettivo
                 filtro. Una stanza viene accettata solo se la capacità è maggiore o uguale (gte) rispetto alla capacità minima del filtro.
                 Analogamente viene fatto con la capacità e la capacità massima, con la differenza che la capacità della stanza deve essere
                 minore o uguale (lte) alla capacità massima.  -->
    <mat-card *ngFor="let room of rooms |  
                      searchfilter: 'name' : filters?.name |
                      numberfilter: 'capacity' : { value : filters?.capacityMin, operator : 'gte' } | 
                      numberfilter: 'capacity' : { value : filters?.capacityMax, operator : 'lte' } |
                      searchfilter: 'wifi' : filters?.wifi |
                      searchfilter: 'socket' : filters?.socket |
                      searchfilter: 'ethernet' : filters?.ethernet |
                      searchfilter: 'computer' : filters?.computer |
                      searchfilter: 'interactiveWhiteboard' : filters?.interactiveWhiteboard ">
      <!-- Nell'header inserisco il titolo della card-->
      <mat-card-header>
        <!-- Che avrà come valore il nome dell'aula -->
        <h3>{{room.name}}</h3>
      </mat-card-header>
      <mat-card-content>
        <!-- Analogamente con quanto fatto col contenitore principale, imposto un contenitore flex per mostrare le caratteristiche
             della stanza e pulsanti in modo responsive -->
        <div fxLayout="row" fxLayout.lt-md="column" fxLayoutAlign="space-evenly stretch" fxLayoutAlign.lt-md="start stretch">
          <!-- Con fxFlex indico che il contenitore usufruirà di eventuale spazio disponibile, di rimpicciolirsi
                  se è troppo largo da non riuscire ad entrarci -->
          <div fxFlex>
            <div>
              <!-- Mostro in grassetto la capacità -->
              <strong>Capacità</strong>: {{room.capacity}}
            </div>
            <!-- Con mat-list mostro una lista di elementi-->
            <mat-list>
              <h3 mat-subheader>Dotazioni</h3>
              <p *ngIf="!(room.wifi||room.socket||room.ethernet||room.computer||room.interactiveWhiteboard)">Nessuna dotazione</p>
              <!-- mat-list-item identifica un elmento della lista, che viene mostrato se tale elmento fa parte della dotazione dell'aula-->
              <mat-list-item *ngIf="room.wifi">
                <!-- mat-icon per mostrare una icona -->
                <mat-icon mat-list-icon>check_circle</mat-icon>
                <p mat-line> Internet WiFi </p>
              </mat-list-item>
              <mat-list-item *ngIf="room.socket">
                <mat-icon mat-list-icon>check_circle</mat-icon>
                <p mat-line> Prese di corrente </p>
              </mat-list-item>
              <mat-list-item *ngIf="room.ethernet">
                <mat-icon mat-list-icon>check_circle</mat-icon>
                <p mat-line> Prese ethernet </p>
              </mat-list-item>
              <mat-list-item *ngIf="room.computer">
                <mat-icon mat-list-icon>check_circle</mat-icon>
                <p mat-line> Computer </p>
              </mat-list-item>
              <mat-list-item *ngIf="room.interactiveWhiteboard">
                <mat-icon mat-list-icon>check_circle</mat-icon>
                <p mat-line> Lavagna interattiva </p>
              </mat-list-item>
            </mat-list>
          </div>
          <!-- Con fxFlex indico che il contenitore usufruirà di eventuale spazio disponibile, di rimpicciolirsi
                  se è troppo largo da non riuscire ad entrarci -->
          <div fxFlex>
            <!-- I bottoni possono fare da collegamenti ad altre sezioni dell'app. 
                       Con mat-raised-button indico lo stile del bottone.
                       Con color indico lo schema di colori che deve possedere il bottone, in questo caso il secondario
                       Con routerLink indico al router a quale pagina dell'app ci si dovrà dirigere quando l'utente vi ci clicca
                       Il tag mat-icon permette di mostrare una icona a schermo. Viene passato il nome dell'icona da visualizzare 
                       Questo bottone viene mostrato solo se è stato impostato il roomIdSelected, altrimenti viene mostrato il
                       template di nome select. Nel caso in cui viene cliccato il bottone, viene eliminata la selezione dell'aula-->

            <button mat-raised-button color="success" (click)="roomSelected(0)" *ngIf="roomIdSelected === room.id; else select">
              <mat-icon>check_circle_outline</mat-icon> Prenotata
            </button>
            <!-- Template del bottone per selezionare l'aula-->
            <ng-template #select>
              <!-- Se si clicca nel bottone, viene chiamata la funzione per salvare il nuovo id della stanza. Viene mostrato solo se
                   è stata selezionata la data-->
              <button mat-raised-button color="primary" (click)="roomSelected(room.id)" *ngIf="date">
                <mat-icon>check</mat-icon> Prenota
              </button>
            </ng-template>


          </div>
        </div>
      </mat-card-content>
    </mat-card>
  </div>
</div>